<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>LLM security in 2025: the confusable deputy problem and deterministic boundaries | Polar Sky</title>
  <link rel="stylesheet" href="/pr-9/assets/site.css">
  <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-K2SDN74B');</script>
<!-- End Google Tag Manager -->

</head>
<body class="page">
  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K2SDN74B"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

  <main class="shell">
    <a class="brand" href="/pr-9/">Polar Sky</a>
    
    
    <div class="post-layout">
      <article class="post" id="post-content">
        <header>
          <h1>LLM security in 2025: the confusable deputy problem and deterministic boundaries</h1>
          <p class="post-meta">January 07, 2025</p>
          <p class="post-meta post-reading-time">Estimated reading time: 4 min</p>
        </header>
        <p>In 2025, LLM capabilities advanced quickly. “Reasoning” models (starting with OpenAI’s o1/o3) helped make agentic workflows meaningfully more useful, and security started to look less like content moderation and more like systems security for a component that <strong>reads untrusted text, reasons over it, and can take action</strong>.</p>

<p>So, looking back on 2025: what did we learn about LLM security?</p>

<h2 id="takeaways">Takeaways</h2>

<ol>
  <li><strong>Deployment is outpacing mature security controls.</strong> As assistants gain access to more data and more actions, “mostly works” becomes a risky default.</li>
  <li><strong>Prompt injection is better thought of as a <a href="https://www.ncsc.gov.uk/blog-post/prompt-injection-is-not-sql-injection">confusable deputy</a> problem.</strong> Models can’t reliably separate instructions from data, so prevention-by-filtering is inherently incomplete.</li>
  <li><strong>Use deterministic boundaries.</strong> Treat untrusted inputs and untrusted outputs as hostile by default; enforce isolation, authorization checks, and gated actions outside the model.</li>
</ol>

<h2 id="big-problem-ai-security-is-normalizing-before-controls-are-mature">Big problem: AI security is normalizing before controls are mature</h2>

<p>A recurring theme in 2025 writing was that organizations can drift into accepting insecure behavior because “nothing catastrophic has happened yet.” Johann Rehberger describes this dynamic for AI systems as a “<a href="https://embracethered.com/blog/posts/2025/the-normalization-of-deviance-in-ai/">normalization of deviance</a>” failure mode.</p>

<p>At the same time, deployments are getting more capable:</p>

<ul>
  <li>assistants ingest more untrusted input (web/email/docs/tickets)</li>
  <li>retrieval-augmented generation (RAG) connects models to sensitive internal corpora</li>
  <li>agents increasingly call tools that can change state</li>
</ul>

<p>That combination shifts impact from reputational harm (“chatbot said something wrong”) toward conventional security outcomes such as data exposure and unauthorized actions (especially when the system operates with user credentials).</p>

<p>One concrete illustration is the <a href="https://brave.com/blog/comet-prompt-injection/">Comet prompt injection issue</a>: webpage content was treated as instructions in a way that could drive unintended behavior and disclosure.</p>

<h2 id="the-ai-threat-model-semantic-unbounded-stochastic">The AI threat model: semantic, unbounded, stochastic</h2>

<p>Classical cybersecurity is built around deterministic systems: you can trace a failure to code paths, configuration, or protocol behavior—and you can often remediate by patching. LLM applications break some of those assumptions:</p>

<ul>
  <li><strong>The attack surface is semantic.</strong> “Instructions” and “data” share the same medium (natural language), and adversarial instructions can be embedded in content the model is asked to process.</li>
  <li><strong>You can’t assume you can enumerate and block all bad inputs.</strong> Because the attack surface is natural language, the space of adversarial inputs is effectively unbounded—input filtering is inherently incomplete (“99% of infinity is still infinity”). Indirect injection is specifically about instructions arriving via normal enterprise content flows (files, emails, web pages).</li>
  <li><strong>You can’t treat model behavior as a security boundary.</strong> Outputs are probabilistic and can be steered; prompt “guardrails” are a layer, not a substitute for authorization checks and isolation boundaries.</li>
</ul>

<p>The “confusable deputy” framing is useful for security decision-making: treat this less like a classic injection bug you can patch away and more like exploitation of an inherently confusable system—pushing design toward impact reduction and boundary controls.</p>

<h2 id="deterministic-boundaries-put-controls-outside-the-model">Deterministic Boundaries: Put Controls Outside the Model</h2>

<p>The most defensible 2025 posture was not “we prevented injection,” but “when injection happens, it can’t silently exfiltrate data or perform high-impact actions.” In practice, that means emphasizing deterministic boundary controls over probabilistic behavior (see Chrome’s published <a href="https://security.googleblog.com/2025/12/architecting-security-for-agentic.html">agent security architecture</a>).</p>

<p>Practically, that means:</p>

<ul>
  <li><strong>Authorize access to data and tools outside the model.</strong> Don’t rely on the model to decide what it’s allowed to retrieve or do (“complete mediation” in downstream systems).</li>
  <li><strong>Separate read paths from write paths.</strong> Treat retrieval as privileged; treat state-changing tool calls as higher risk; require approvals for high-impact actions.</li>
  <li><strong>Treat model output as untrusted.</strong> Validate/sanitize before passing output into interpreters (HTML/JS/SQL/shell/config); prefer structured outputs and strict parsing.</li>
  <li><strong>Instrument and respond like any other privileged system.</strong> Log retrieval decisions and tool invocations; build detection and incident response around anomalous export/tool use.</li>
</ul>

<h2 id="2025-control-priorities-for-agentic-systems">2025: Control Priorities for Agentic Systems</h2>

<p>Most “best practice” controls for access control, least privilege, and logging were not invented in 2025. What changed in 2025 is that major examples and guidance started converging on a clear set of priorities for agentic systems:</p>

<ul>
  <li><strong>Treat untrusted content as hostile by default.</strong> The <a href="https://brave.com/blog/comet-prompt-injection/">Comet prompt injection issue</a> is a concrete reminder that content can be interpreted as instructions and drive unintended behavior or disclosure.</li>
  <li><strong>Treat LLM outputs as untrusted by default.</strong> Don’t execute or forward raw generations into interpreters (HTML/JS/SQL/shell) without strict validation/sanitization; prefer structured outputs and “policy checks outside the model.”</li>
  <li><strong>Make the security boundary deterministic.</strong> Isolate untrusted content, gate high-impact actions, and enforce authorization downstream rather than relying on “the model will comply.”</li>
</ul>

<h2 id="conclusion-assume-injection-reduce-blast-radius">Conclusion: Assume Injection, Reduce Blast Radius</h2>

<p>The core lesson from 2025 was that deployment is outpacing mature security controls. The emerging mindset shifted from “prevent prompt injection” to “assume injection succeeds sometimes, and make failures non-catastrophic through boundaries, authorization, and isolation.”</p>

<blockquote>
  <p>“… any data that AI has access to, the user can make it leak it. Any actions that it can possibly take, the user can make it take. So make sure to have those things locked down.” — Sander Schulhoff, leading AI cybersecurity researcher (<a href="https://www.lennysnewsletter.com/p/the-coming-ai-security-crisis">Lenny’s Newsletter podcast</a>)</p>
</blockquote>

      </article>
      <aside class="post-toc" aria-label="Table of contents">
        <p class="post-toc__title">On this page</p>
        <ol class="post-toc__list"></ol>
      </aside>
    </div>
  </main>
  <script>
    (() => {
      const toc = document.querySelector(".post-toc");
      const tocList = document.querySelector(".post-toc__list");
      const headings = document.querySelectorAll(".post h2");

      if (!toc || !tocList || headings.length === 0) {
        if (toc) {
          toc.remove();
        }
        return;
      }

      const slugify = (text) =>
        text
          .toLowerCase()
          .trim()
          .replace(/[^\w\s-]/g, "")
          .replace(/\s+/g, "-");

      const used = new Map();

      headings.forEach((heading) => {
        if (heading.classList.contains("post-reading-time")) {
          return;
        }
        if (!heading.id) {
          const base = slugify(heading.textContent);
          const count = used.get(base) || 0;
          const id = count ? `${base}-${count}` : base;
          used.set(base, count + 1);
          heading.id = id;
        }

        const item = document.createElement("li");
        item.className = "post-toc__item";

        const link = document.createElement("a");
        link.href = `#${heading.id}`;
        link.textContent = heading.textContent;
        item.appendChild(link);
        tocList.appendChild(item);
      });
    })();
  </script>
</body>
</html>

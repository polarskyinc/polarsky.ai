<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>LLM security in 2025: confusable deputies, indirect injection, and controls that reduce blast radius | Polar Sky</title>
  <link rel="stylesheet" href="/pr-9/assets/site.css">
  <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-K2SDN74B');</script>
<!-- End Google Tag Manager -->

</head>
<body class="page">
  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K2SDN74B"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

  <main class="shell">
    <a class="brand" href="/pr-9/">Polar Sky</a>
    
    
    <div class="post-layout">
      <article class="post" id="post-content">
        <header>
          <h1>LLM security in 2025: confusable deputies, indirect injection, and controls that reduce blast radius</h1>
          <p class="post-meta">January 07, 2025</p>
          <p class="post-meta post-reading-time">Estimated reading time: 5 min</p>
        </header>
        <p>In 2025, LLM capabilities advanced quickly. “Reasoning” models (starting with OpenAI’s o1/o3) helped make agentic workflows meaningfully more useful, and security started to look less like content moderation and more like systems security for a component that <strong>reads untrusted text, reasons over it, and can take action</strong>.</p>

<p>So, looking back on 2025: what did we learn about LLM security?</p>

<h2 id="summary">Summary</h2>

<ul>
  <li><strong>Deployment is outpacing mature security controls.</strong> As assistants gain access to more data and more actions, “mostly works” becomes a risky default.</li>
  <li><strong>Prompt injection is better modeled as a confusable deputy problem.</strong> The model can’t reliably separate instructions from data, and that pushes designs toward boundaries and impact reduction (<a href="https://www.ncsc.gov.uk/blog-post/prompt-injection-is-not-sql-injection">UK NCSC</a>).</li>
  <li><strong>The practical answer is deterministic boundary controls.</strong> Isolation of untrusted content, explicit authorization checks, and gating high-impact actions are replacing “prompt-only” security arguments (<a href="https://security.googleblog.com/2025/12/architecting-security-for-agentic.html">Chrome Security</a>).</li>
</ul>

<h2 id="big-problem-ai-security-is-normalizing-before-controls-are-mature">Big problem: AI security is normalizing before controls are mature</h2>

<p>A recurring theme in 2025 writing was that organizations can drift into accepting insecure behavior because “nothing catastrophic has happened yet.” Johann Rehberger describes this dynamic for AI systems as a “<a href="https://embracethered.com/blog/posts/2025/the-normalization-of-deviance-in-ai/">normalization of deviance</a>” failure mode.</p>

<p>At the same time, deployments are getting more capable:</p>

<ul>
  <li>assistants ingest more untrusted input (web/email/docs/tickets)</li>
  <li>retrieval-augmented generation (RAG) connects models to sensitive internal corpora</li>
  <li>agents increasingly call tools that can change state</li>
</ul>

<p>That combination shifts impact from reputational harm (“chatbot said something wrong”) toward conventional security outcomes such as data exposure and unauthorized actions (especially when the system operates with user credentials).</p>

<p>One concrete illustration is the Comet prompt injection issue described by <a href="https://brave.com/blog/comet-prompt-injection/">Brave</a>: webpage content was treated as instructions in a way that could drive unintended behavior and disclosure.</p>

<h2 id="confusable-deputy-not-prompt-injection-the-ai-threat-model">Confusable deputy, not “prompt injection”: the AI threat model</h2>

<p>Classical cybersecurity is built around deterministic systems: you can trace a failure to code paths, configuration, or protocol behavior—and you can often remediate by patching. LLM applications break some of those assumptions:</p>

<ul>
  <li><strong>The attack surface is semantic.</strong> “Instructions” and “data” share the same medium (natural language), and adversarial instructions can be embedded in content the model is asked to process.</li>
  <li><strong>You can’t assume you can enumerate and block all bad inputs.</strong> Because the attack surface is natural language, the space of adversarial inputs is effectively unbounded—input filtering is inherently incomplete (“99% of infinity is still infinity”). Indirect injection is specifically about instructions arriving via normal enterprise content flows (files, emails, web pages).</li>
  <li><strong>You can’t treat model behavior as a security boundary.</strong> Outputs are probabilistic and can be steered; prompt “guardrails” are a layer, not a substitute for authorization checks and isolation boundaries.</li>
</ul>

<p>The “confusable deputy” framing is useful for security decision-making: treat prompt injection less like SQL injection and more like exploitation of an inherently confusable system, pushing design toward impact reduction and boundary controls (as discussed above).</p>

<h2 id="whats-the-solution-build-controls-that-reduce-blast-radius-when-injection-succeeds">What’s the solution? Build controls that reduce blast radius when injection succeeds</h2>

<p>The most defensible 2025 posture was not “we prevented injection,” but “when injection happens, it can’t silently exfiltrate data or perform high-impact actions.” In practice, that means emphasizing deterministic boundary controls over probabilistic behavior (see Chrome’s <a href="https://security.googleblog.com/2025/12/architecting-security-for-agentic.html">agent security architecture</a>).</p>

<p>Practically, that means:</p>

<ul>
  <li><strong>Authorize access to data and tools outside the model.</strong> Don’t rely on the model to decide what it’s allowed to retrieve or do (“complete mediation” in downstream systems).</li>
  <li><strong>Separate read paths from write paths.</strong> Treat retrieval as privileged; treat state-changing tool calls as higher risk; require approvals for high-impact actions.</li>
  <li><strong>Treat model output as untrusted.</strong> Validate/sanitize before passing output into interpreters (HTML/JS/SQL/shell/config); prefer structured outputs and strict parsing.</li>
  <li><strong>Instrument and respond like any other privileged system.</strong> Log retrieval decisions and tool invocations; build detection and incident response around anomalous export/tool use.</li>
</ul>

<h2 id="six-2025-takeaways-for-cisos-on-llm-security">Six 2025 takeaways for CISOs on LLM security</h2>

<h3 id="1-deployment-outpaced-controls-design-for-failure-not-perfection">1) Deployment outpaced controls (design for failure, not perfection)</h3>
<p>As capabilities expanded, near-misses and “mostly works” behaviors became easier to normalize and harder to reason about.</p>

<h3 id="2-prompt-injection-is-a-confusable-deputy-problem-not-a-bug-class-you-can-patch-away">2) Prompt injection is a confusable deputy problem, not a bug class you can patch away</h3>
<p>The model can’t reliably separate instructions from data, which pushes designs toward impact reduction and boundary controls (<a href="https://www.ncsc.gov.uk/blog-post/prompt-injection-is-not-sql-injection">UK NCSC</a>).</p>

<h3 id="3-indirect-injection-is-the-enterprise-delivery-path-for-ai-that-reads">3) Indirect injection is the enterprise delivery path for “AI that reads”</h3>
<p>If a workflow asks an LLM to summarize or analyze untrusted content (web/email/docs/tickets), you have a practical injection path. Microsoft’s MSRC write-up is a useful, concrete description of indirect prompt injection delivery paths and associated defenses (see <a href="https://www.microsoft.com/en-us/msrc/blog/2025/07/how-microsoft-defends-against-indirect-prompt-injection-attacks">Microsoft MSRC</a>). Agentic browsing makes this risk especially concrete (see <a href="https://brave.com/blog/comet-prompt-injection/">Brave</a>).</p>

<h3 id="4-deterministic-boundary-controls-became-the-default-direction-of-travel">4) Deterministic boundary controls became the default direction of travel</h3>
<p>Published architectures emphasize isolating untrusted content, gating high-impact actions, and enforcing downstream authorization checks (<a href="https://security.googleblog.com/2025/12/architecting-security-for-agentic.html">Chrome Security</a>).</p>

<h3 id="5-delegation-and-multi-agent-systems-create-second-order-escalation-paths">5) Delegation and multi-agent systems create second-order escalation paths</h3>
<p>Agent-to-agent discovery and delegation can create interactions that look like lateral movement (<a href="https://appomni.com/ao-labs/ai-agent-to-agent-discovery-prompt-injection/">AppOmni</a>).</p>

<h3 id="6-ai-orchestrated-ops-signals-emerged-but-risk-should-be-calibrated-from-primary-sources">6) “AI-orchestrated ops” signals emerged, but risk should be calibrated from primary sources</h3>
<p>There is credible reporting of agentic usage in cyber operations; CISOs should read primary sources and update assumptions incrementally (<a href="https://www.anthropic.com/news/disrupting-AI-espionage">Anthropic</a>).</p>

<h2 id="what-changed-for-controls-in-2025">What changed for controls in 2025</h2>

<p>Most “best practice” controls for access control, least privilege, and logging were not invented in 2025. What changed in 2025 is that major examples and guidance started converging on a smaller set of priorities for agentic systems:</p>

<ul>
  <li><strong>Treat untrusted content as hostile by default.</strong> The Comet prompt injection issue is a concrete reminder that content can be interpreted as instructions and drive unintended behavior or disclosure (<a href="https://brave.com/blog/comet-prompt-injection/">Brave</a>).</li>
  <li><strong>Treat LLM outputs as untrusted by default.</strong> Don’t execute or forward raw generations into interpreters (HTML/JS/SQL/shell) without strict validation/sanitization; prefer structured outputs and “policy checks outside the model.”</li>
  <li><strong>Make the security boundary deterministic.</strong> Isolate untrusted content, gate high-impact actions, and enforce authorization downstream rather than relying on “the model will comply” (<a href="https://security.googleblog.com/2025/12/architecting-security-for-agentic.html">Chrome Security</a>).</li>
</ul>

<h2 id="closing-the-posture-that-held-up-in-2025">Closing: the posture that held up in 2025</h2>

<p>The core lesson from 2025 was a shift from “prevent prompt injection” to “assume injection succeeds sometimes, and make failures non-catastrophic through boundaries, authorization, and isolation.”</p>

<blockquote>
  <p>“… any data that AI has access to, the user can make it leak it. Any actions that it can possibly take, the user can make it take. So make sure to have those things locked down.” — Sander Schulhoff, leading AI cybersecurity researcher (<a href="https://www.lennysnewsletter.com/p/the-coming-ai-security-crisis">Lenny’s Newsletter podcast</a>)</p>
</blockquote>

      </article>
      <aside class="post-toc" aria-label="Table of contents">
        <p class="post-toc__title">On this page</p>
        <ol class="post-toc__list"></ol>
      </aside>
    </div>
  </main>
  <script>
    (() => {
      const toc = document.querySelector(".post-toc");
      const tocList = document.querySelector(".post-toc__list");
      const headings = document.querySelectorAll(".post h2");

      if (!toc || !tocList || headings.length === 0) {
        if (toc) {
          toc.remove();
        }
        return;
      }

      const slugify = (text) =>
        text
          .toLowerCase()
          .trim()
          .replace(/[^\w\s-]/g, "")
          .replace(/\s+/g, "-");

      const used = new Map();

      headings.forEach((heading) => {
        if (heading.classList.contains("post-reading-time")) {
          return;
        }
        if (!heading.id) {
          const base = slugify(heading.textContent);
          const count = used.get(base) || 0;
          const id = count ? `${base}-${count}` : base;
          used.set(base, count + 1);
          heading.id = id;
        }

        const item = document.createElement("li");
        item.className = "post-toc__item";

        const link = document.createElement("a");
        link.href = `#${heading.id}`;
        link.textContent = heading.textContent;
        item.appendChild(link);
        tocList.appendChild(item);
      });
    })();
  </script>
</body>
</html>
